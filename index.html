<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mini Shooter 3D Web</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; height: 100%;
    background: #111;
    font-family: Arial, sans-serif;
    color: white;
    user-select:none;
  }
  #hud {
    position: fixed;
    top: 10px; left: 10px;
    font-size: 18px;
    background: rgba(0,0,0,0.5);
    padding: 10px 15px;
    border-radius: 10px;
    z-index: 10;
    width: 180px;
  }
  #instructions {
    position: fixed;
    bottom: 15px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 14px;
    background: rgba(0,0,0,0.7);
    padding: 8px 12px;
    border-radius: 8px;
    max-width: 90vw;
    text-align: center;
    user-select:none;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>

<div id="hud">
  <div>Vie : <span id="health">100</span></div>
  <div>Munitions : <span id="ammo">30</span></div>
  <div>Ennemis tués : <span id="score">0</span></div>
</div>
<div id="instructions">
  WASD = Déplacer, Souris = Regarder, Clic ou barre Espace = Tirer
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/PointerLockControls.js"></script>

<script>
(() => {
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  // Camera setup
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  // Renderer
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // PointerLockControls pour contrôle souris 1ere personne
  const controls = new THREE.PointerLockControls(camera, document.body);

  // Instructions pour activer PointerLock
  const instructions = document.getElementById('instructions');
  instructions.addEventListener('click', () => {
    controls.lock();
  });
  controls.addEventListener('lock', () => { instructions.style.display = 'none'; });
  controls.addEventListener('unlock', () => { instructions.style.display = 'block'; });

  // Lumières
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambientLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  // Sol (plan)
  const floorGeometry = new THREE.PlaneGeometry(200, 200);
  const floorMaterial = new THREE.MeshStandardMaterial({color: 0x333333});
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  // Joueur (invisible, la caméra est la tête)
  const player = {
    height: 1.8,
    speed: 6,
    velocity: new THREE.Vector3(),
    direction: new THREE.Vector3(),
    canShoot: true,
    ammo: 30,
    health: 100,
    score: 0,
    boundingBox: new THREE.Box3()
  };

  // Variables pour déplacement clavier
  const keysPressed = {};
  document.addEventListener('keydown', e => { keysPressed[e.code] = true; });
  document.addEventListener('keyup', e => { keysPressed[e.code] = false; });

  // Balle
  class Bullet {
    constructor(position, direction) {
      this.speed = 30;
      this.life = 3; // secondes avant disparition
      this.geometry = new THREE.SphereGeometry(0.05, 8, 8);
      this.material = new THREE.MeshBasicMaterial({color: 0xffff00});
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      this.mesh.position.copy(position);
      this.direction = direction.clone().normalize();
      scene.add(this.mesh);
    }
    update(delta) {
      this.mesh.position.addScaledVector(this.direction, this.speed * delta);
      this.life -= delta;
      if (this.life <= 0) return false;
      return true;
    }
    dispose() {
      scene.remove(this.mesh);
      this.geometry.dispose();
      this.material.dispose();
    }
  }

  // Ennemis
  class Enemy {
    constructor(position) {
      this.speed = 2;
      this.health = 20;
      this.geometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
      this.material = new THREE.MeshStandardMaterial({color: 0xff3333});
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      this.mesh.position.copy(position);
      this.boundingBox = new THREE.Box3().setFromObject(this.mesh);
      scene.add(this.mesh);
    }
    update(delta, playerPos) {
      const dir = playerPos.clone().sub(this.mesh.position).normalize();
      this.mesh.position.addScaledVector(dir, this.speed * delta);
      this.boundingBox.setFromObject(this.mesh);
    }
    damage(amount) {
      this.health -= amount;
      if (this.health <= 0) {
        this.destroy();
        return true;
      }
      return false;
    }
    destroy() {
      scene.remove(this.mesh);
      this.geometry.dispose();
      this.material.dispose();
    }
  }

  // Variables jeu
  const bullets = [];
  const enemies = [];
  let lastEnemySpawn = 0;
  const enemySpawnInterval = 3; // secondes
  const bulletDamage = 10;

  // HUD éléments
  const healthSpan = document.getElementById('health');
  const ammoSpan = document.getElementById('ammo');
  const scoreSpan = document.getElementById('score');

  // Sons
  const listener = new THREE.AudioListener();
  camera.add(listener);
  const audioLoader = new THREE.AudioLoader();
  const soundShoot = new THREE.Audio(listener);
  const soundHit = new THREE.Audio(listener);
  const soundMusic = new THREE.Audio(listener);

  audioLoader.load('https://freesound.org/data/previews/402/402175_5121236-lq.mp3', buffer => {
    soundShoot.setBuffer(buffer);
    soundShoot.setVolume(0.3);
  });
  audioLoader.load('https://freesound.org/data/previews/170/170151_2437358-lq.mp3', buffer => {
    soundHit.setBuffer(buffer);
    soundHit.setVolume(0.3);
  });
  audioLoader.load('https://files.catbox.moe/uc4kgx.mp3', buffer => {
    soundMusic.setBuffer(buffer);
    soundMusic.setLoop(true);
    soundMusic.setVolume(0.15);
    soundMusic.play();
  });

  // Tir
  function shoot() {
    if (!player.canShoot || player.ammo <= 0) return;
    player.ammo--;
    ammoSpan.textContent = player.ammo;
    player.canShoot = false;
    soundShoot.play();
    // Position devant la caméra, ajustée un peu bas
    const shootPos = new THREE.Vector3();
    shootPos.setFromMatrixPosition(camera.matrixWorld);
    const shootDir = new THREE.Vector3();
    camera.getWorldDirection(shootDir);
    bullets.push(new Bullet(shootPos, shootDir));
    setTimeout(() => { player.canShoot = true; }, 300); // cadence tir
  }

  // Gestion collisions simple AABB bullet/enemy
  function checkBulletEnemyCollisions() {
    bullets.forEach((b, i) => {
      enemies.forEach((e, j) => {
        const bulletBox = new THREE.Box3().setFromCenterAndSize(b.mesh.position, new THREE.Vector3(0.1,0.1,0.1));
        if (bulletBox.intersectsBox(e.boundingBox)) {
          // Dégâts
          if (e.damage(bulletDamage)) {
            enemies.splice(j,1);
            player.score++;
            scoreSpan.textContent = player.score;
            soundHit.play();
            spawnExplosion(e.mesh.position);
          }
          // Détruire balle
          b.dispose();
          bullets.splice(i,1);
        }
      });
    });
  }

  // Explosion simple particules
  const particles = [];
  class Particle {
    constructor(pos){
      this.position = pos.clone();
      this.life = 1;
      this.size = Math.random()*0.1 + 0.05;
      this.velocity = new THREE.Vector3(
        (Math.random()-0.5)*2,
        Math.random()*2,
        (Math.random()-0.5)*2
      );
      this.geometry = new THREE.SphereGeometry(this.size, 6, 6);
      this.material = new THREE.MeshBasicMaterial({color: 0xffcc00});
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      this.mesh.position.copy(this.position);
      scene.add(this.mesh);
    }
    update(delta){
      this.velocity.y -= 5*delta;
      this.position.addScaledVector(this.velocity, delta);
      this.mesh.position.copy(this.position);
      this.life -= delta;
      if(this.life <= 0){
        scene.remove(this.mesh);
        this.geometry.dispose();
        this.material.dispose();
        return false;
      }
      return true;
    }
  }
  function spawnExplosion(position){
    for(let i=0; i<15; i++){
      particles.push(new Particle(position));
    }
  }

  // Spawn ennemi aléatoire autour joueur
  function spawnEnemy(){
    const distance = 20 + Math.random()*10;
    const angle = Math.random()*Math.PI*2;
    const pos = new THREE.Vector3(
      Math.cos(angle)*distance,
      0.9,
      Math.sin(angle)*distance
    );
    enemies.push(new Enemy(pos));
  }

  // Mise à jour joueur position et collisions sol simple
  function updatePlayer(delta){
    player.direction.set(0,0,0);
    if(keysPressed['KeyW']) player.direction.z -= 1;
    if(keysPressed['KeyS']) player.direction.z += 1;
    if(keysPressed['KeyA']) player.direction.x -= 1;
    if(keysPressed['KeyD']) player.direction.x += 1;
    player.direction.normalize();

    if(controls.isLocked){
      // Déplacement relatif à la direction caméra
      const angle = controls.getObject().rotation.y;
      const forward = new THREE.Vector3(
        Math.sin(angle),
        0,
        Math.cos(angle)
      );
      const right = new THREE.Vector3(
        Math.sin(angle + Math.PI/2),
        0,
        Math.cos(angle + Math.PI/2)
      );

      const move = new THREE.Vector3();
      move.addScaledVector(forward, -player.direction.z);
      move.addScaledVector(right, -player.direction.x);
      move.normalize();

      move.multiplyScalar(player.speed * delta);
      controls.getObject().position.add(move);

      // Limites du terrain
      const pos = controls.getObject().position;
      pos.x = Math.min(90, Math.max(-90, pos.x));
      pos.z = Math.min(90, Math.max(-90, pos.z));
      pos.y = player.height; // hauteur constante
    }
  }

  // Gestion dommages ennemis -> joueur si proches
  function enemyAttack(delta){
    enemies.forEach(e => {
      const dist = e.mesh.position.distanceTo(controls.getObject().position);
      if(dist < 1.5){
        player.health -= 15 * delta; // dégâts continus
        player.health = Math.max(0, player.health);
        healthSpan.textContent = Math.floor(player.health);
        if(player.health <= 0){
          gameOver();
        }
      }
    });
  }

  // Fin de partie
  function gameOver(){
    controls.unlock();
    alert(`💀 Game Over ! Tu as tué ${player.score} ennemis.`);
    location.reload();
  }

  // Événements tir
  window.addEventListener('click', shoot);
  window.addEventListener('keydown', e => {
    if(e.code === 'Space') {
      shoot();
      e.preventDefault();
    }
  });

  // Redimensionnement
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Position initiale caméra (player)
  controls.getObject().position.set(0, player.height, 0);
  scene.add(controls.getObject());

  // Boucle principale
  let lastTime = performance.now();
  function animate() {
    requestAnimationFrame(animate);
    const now = performance.now();
    const delta = (now - lastTime)/1000;
    lastTime = now;

    if(controls.isLocked){
      updatePlayer(delta);

      bullets.forEach((b,i) => {
        if(!b.update(delta)){
          b.dispose();
          bullets.splice(i,1);
        }
      });

      enemies.forEach((e,i) => {
        e.update(delta, controls.getObject().position);
      });

      checkBulletEnemyCollisions();
      enemyAttack(delta);

      // Spawn ennemis
      lastEnemySpawn += delta;
      if(lastEnemySpawn > enemySpawnInterval){
        spawnEnemy();
        lastEnemySpawn = 0;
      }
    }

    // Mise à jour particules explosion
    for(let i = particles.length-1; i>=0; i--){
      if(!particles[i].update(delta)) particles.splice(i,1);
    }

    renderer.render(scene, camera);
  }
  animate();

})();
</script>

</body>
</html>
