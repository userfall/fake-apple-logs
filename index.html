<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>KabirCam Pro - Intrusion Avancée</title>
<style>
  /* Reset & base */
  * {
    box-sizing: border-box;
  }
  html, body {
    margin:0; padding:0; height:100%;
    background: #0a0f0a;
    color: #00ff44;
    font-family: 'Courier New', Courier, monospace;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
  }
  body {
    background: radial-gradient(ellipse at center, #001000 0%, #000000 90%);
  }

  /* Screens */
  #welcomeScreen, #cameraScreen, #terminalScreen {
    width: 100vw;
    max-width: 640px;
    height: 100vh;
    padding: 24px 32px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    user-select: none;
    position: relative;
    overflow: hidden;
  }
  .hidden {
    display: none !important;
  }

  /* Welcome Screen */
  #welcomeScreen h1 {
    font-size: 3rem;
    margin-bottom: 20px;
    text-shadow: 0 0 20px #00ff44aa;
  }
  #welcomeScreen p {
    font-size: 1.4rem;
    margin-bottom: 32px;
    color: #00cc33;
  }
  #startCameraBtn {
    cursor: pointer;
    background: linear-gradient(135deg, #004400, #007700);
    border: 2px solid #00ff44;
    color: #00ff44;
    font-weight: 700;
    font-size: 1.5rem;
    padding: 18px 42px;
    border-radius: 12px;
    transition: background 0.3s ease;
    user-select: none;
  }
  #startCameraBtn:hover {
    background: linear-gradient(135deg, #007700, #00cc33);
  }

  /* Camera Screen */
  #cameraScreen h2 {
    font-size: 2.4rem;
    margin-bottom: 22px;
    text-shadow: 0 0 16px #00ff44cc;
  }
  #cameraVideo {
    width: 100%;
    max-width: 620px;
    border-radius: 16px;
    border: 6px solid #00ff44cc;
    box-shadow: 0 0 25px #00ff44aa;
    background-color: #000;
    user-select: none;
  }
  #cameraLoadingText {
    margin-top: 12px;
    font-style: italic;
    color: #008800cc;
  }

  /* Red overlay flash + glitch for transition */
  #redFlash {
    position: fixed;
    inset: 0;
    background: rgba(255,0,0,0);
    pointer-events: none;
    z-index: 9999;
    transition: background 0.7s ease;
  }
  #redFlash.active {
    background: rgba(255,0,0,0.85);
    animation: pulseRed 1.2s ease-in-out infinite alternate;
  }
  @keyframes pulseRed {
    0% { background: rgba(255,0,0,0.65); }
    100% { background: rgba(255,0,0,0.9); }
  }
  /* Glitch effect on terminal */
  @keyframes glitch {
    0% { text-shadow: 2px 0 red, -2px 0 cyan; }
    20% { text-shadow: -2px 0 red, 2px 0 cyan; }
    40% { text-shadow: 2px 2px red, -2px -2px cyan; }
    60% { text-shadow: -2px -2px red, 2px 2px cyan; }
    80% { text-shadow: 2px 0 red, -2px 0 cyan; }
    100% { text-shadow: -2px 0 red, 2px 0 cyan; }
  }

  /* Terminal Screen */
  #terminalScreen {
    background: #000000dd;
    border: 4px solid #00ff44;
    box-shadow: 0 0 30px #00ff44aa inset;
    border-radius: 20px;
    font-size: 1.15rem;
    letter-spacing: 1.3px;
    line-height: 1.3;
    padding: 28px 32px;
    color: #00ff44;
    font-family: 'Courier New', Courier, monospace;
    white-space: pre-wrap;
    overflow-y: auto;
    user-select: text;
    position: relative;
    z-index: 10;
  }

  .blinking-cursor {
    border-right: 2px solid #00ff44;
    animation: blink 1s steps(2, start) infinite;
    display: inline-block;
  }
  @keyframes blink {
    0%, 50% { border-color: #00ff44; }
    51%, 100% { border-color: transparent; }
  }

  /* Scrollbar for terminal */
  #terminalScreen::-webkit-scrollbar {
    width: 14px;
  }
  #terminalScreen::-webkit-scrollbar-thumb {
    background-color: #00ff44cc;
    border-radius: 7px;
    border: 3px solid transparent;
    background-clip: content-box;
  }
  #terminalScreen::-webkit-scrollbar-track {
    background: #001000;
  }

  /* Final alert style */
  #finalAlert {
    margin-top: 36px;
    font-size: 1.8rem;
    font-weight: 900;
    letter-spacing: 1.8px;
    color: #ff2200;
    text-shadow: 0 0 30px #ff2200cc;
    text-align: center;
    user-select: none;
    animation: glitch 1.5s infinite;
  }

  /* Network noise sound wave overlay for terminal */
  #noiseOverlay {
    pointer-events: none;
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(
      45deg,
      rgba(0,255,0,0.06),
      rgba(0,255,0,0.06) 1px,
      transparent 2px,
      transparent 4px
    );
    opacity: 0.12;
    animation: noiseMove 1.3s linear infinite;
    z-index: 8;
  }
  @keyframes noiseMove {
    0% { background-position: 0 0; }
    100% { background-position: 100px 100px; }
  }

  /* Glitch text effect for terminal lines */
  .glitch-text {
    animation: glitch 0.6s infinite;
  }

  /* Camera small preview on terminal */
  #cameraPreview {
    position: fixed;
    top: 12px;
    right: 12px;
    width: 160px;
    height: 120px;
    border: 3px solid #00ff44;
    border-radius: 12px;
    box-shadow: 0 0 20px #00ff44aa;
    background-color: #000;
    overflow: hidden;
    z-index: 99999;
  }
  #cameraPreview video {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* Progress bar container */
  #progressBarContainer {
    width: 100%;
    max-width: 590px;
    background: #003300bb;
    border: 2px solid #00ff44;
    border-radius: 14px;
    margin-top: 22px;
    overflow: hidden;
    height: 22px;
    user-select: none;
  }
  #progressBar {
    height: 100%;
    width: 0;
    background: linear-gradient(90deg, #00ff44, #00bb00);
    border-radius: 14px 0 0 14px;
    box-shadow: 0 0 15px #00ff44aa;
    transition: width 0.15s ease-out;
  }

  /* Responsive */
  @media (max-width: 700px) {
    #welcomeScreen, #cameraScreen, #terminalScreen {
      max-width: 100vw;
      padding: 18px 20px;
    }
    #welcomeScreen h1 {
      font-size: 2.4rem;
    }
    #cameraScreen h2 {
      font-size: 1.9rem;
    }
    #startCameraBtn {
      padding: 16px 34px;
      font-size: 1.3rem;
    }
    #terminalScreen {
      font-size: 1rem;
      letter-spacing: 1.1px;
      padding: 20px 24px;
    }
    #finalAlert {
      font-size: 1.5rem;
    }
    #cameraPreview {
      width: 120px;
      height: 90px;
      top: 8px;
      right: 8px;
    }
    #progressBarContainer {
      max-width: 100%;
      height: 18px;
      margin-top: 16px;
    }
  }

  /* Matrix background behind terminal */
  #matrixBackground {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 5;
    font-family: monospace;
    color: #00ff44cc;
    user-select: none;
    display: flex;
    overflow: hidden;
  }
  .matrix-column {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    font-weight: 700;
    animation-name: matrixFall;
    animation-timing-function: linear;
    animation-iteration-count: infinite;
  }
  /* Different animation durations for natural effect */
  .matrix-column:nth-child(odd) {
    animation-duration: 8s;
  }
  .matrix-column:nth-child(even) {
    animation-duration: 12s;
  }
  @keyframes matrixFall {
    0% { transform: translateY(-100%); }
    100% { transform: translateY(100%); }
  }
</style>
</head>
<body>

<!-- Step 1 : Accueil -->
<div id="welcomeScreen" aria-label="Ecran d'accueil">
  <h1>KABIR SYSTEM</h1>
  <p>Cliquez pour activer la caméra frontale</p>
  <button id="startCameraBtn" aria-label="Activer la caméra">Activer caméra</button>
</div>

<!-- Step 2 : Caméra active -->
<div id="cameraScreen" class="hidden" aria-label="Caméra activée">
  <h2>Caméra activée</h2>
  <video id="cameraVideo" autoplay muted playsinline></video>
  <p id="cameraLoadingText">Veuillez patienter...</p>
</div>

<!-- Step 2.5 : Flash rouge -->
<div id="redFlash"></div>

<!-- Step 3 : Terminal intrusion -->
<div id="terminalScreen" class="hidden" aria-live="polite" aria-atomic="true" role="log" tabindex="0" aria-label="Terminal intrusion">
  <div id="matrixBackground" aria-hidden="true"></div>
  <div id="noiseOverlay"></div>
</div>

<!-- Camera preview during intrusion -->
<div id="cameraPreview" class="hidden" aria-hidden="true">
  <video autoplay muted playsinline></video>
</div>

<script>
  const welcomeScreen = document.getElementById('welcomeScreen');
  const cameraScreen = document.getElementById('cameraScreen');
  const terminalScreen = document.getElementById('terminalScreen');
  const redFlash = document.getElementById('redFlash');
  const btnStartCamera = document.getElementById('startCameraBtn');
  const cameraVideo = document.getElementById('cameraVideo');
  const cameraLoadingText = document.getElementById('cameraLoadingText');
  const cameraPreview = document.getElementById('cameraPreview');
  const cameraPreviewVideo = cameraPreview.querySelector('video');
  const matrixBackground = document.getElementById('matrixBackground');

  let stream = null;
  let audioCtx = null;
  let intrusionTimeout = null;
  let staticNoiseOscillator = null;
  let staticNoiseGain = null;

  // Generate random chars for matrix effect
  const matrixChars = "01";

  // Create columns for matrix effect
  function createMatrixColumns(count) {
    for(let i = 0; i < count; i++) {
      const col = document.createElement('div');
      col.className = 'matrix-column';
      col.style.animationDuration = (8 + Math.random() * 6).toFixed(2) + 's';

      // Fill column with random chars
      const colHeight = 30 + Math.floor(Math.random() * 40);
      let text = "";
      for(let j = 0; j < colHeight; j++) {
        text += matrixChars.charAt(Math.floor(Math.random() * matrixChars.length)) + "\n";
      }
      col.textContent = text;
      matrixBackground.appendChild(col);
    }
  }

  createMatrixColumns(50);

  // WebAudio beep helper
  function beep(frequency=900, duration=100, type='square', volume=0.08) {
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);
    gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration/1000);
    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration/1000);
  }

  // Beep error & alert
  function beepError() { beep(400, 160, 'square', 0.12); }
  function beepAlert() { beep(320, 300, 'sawtooth', 0.15); }

  // Start background static noise (white noise)
  function startStaticNoise() {
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if(staticNoiseOscillator) return; // already running

    // create noise buffer
    const bufferSize = 2 * audioCtx.sampleRate;
    const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const output = noiseBuffer.getChannelData(0);
    for(let i=0; i<bufferSize; i++) {
      output[i] = Math.random()*2 -1;
    }
    const whiteNoise = audioCtx.createBufferSource();
    whiteNoise.buffer = noiseBuffer;
    whiteNoise.loop = true;

    staticNoiseGain = audioCtx.createGain();
    staticNoiseGain.gain.setValueAtTime(0.015, audioCtx.currentTime);

    whiteNoise.connect(staticNoiseGain);
    staticNoiseGain.connect(audioCtx.destination);

    whiteNoise.start(0);

    staticNoiseOscillator = whiteNoise;
  }
  // Stop background noise
  function stopStaticNoise() {
    if(staticNoiseOscillator) {
      staticNoiseOscillator.stop();
      staticNoiseOscillator.disconnect();
      staticNoiseOscillator = null;
    }
    if(staticNoiseGain) {
      staticNoiseGain.disconnect();
      staticNoiseGain = null;
    }
  }

  // Typewriter effect, with optional beep on line end and error beep
  async function typeLine(text, delay=18, beepOnEnd=true, error=false) {
    return new Promise(resolve => {
      let i=0;
      const cursor = document.createElement('span');
      cursor.className = 'blinking-cursor';
      terminalScreen.appendChild(cursor);

      function typeChar() {
        if(i < text.length) {
          cursor.insertAdjacentText('beforebegin', text[i]);
          i++;
          setTimeout(typeChar, delay + Math.random()*8);
        } else {
          if(beepOnEnd) {
            if(error) beepError();
            else beep();
          }
          terminalScreen.removeChild(cursor);
          terminalScreen.appendChild(document.createTextNode('\n'));
          terminalScreen.scrollTop = terminalScreen.scrollHeight;
          setTimeout(resolve, 200);
        }
      }
      typeChar();
    });
  }

  // Simulate file transfer progress bar
  async function simulateProgressBar(duration=7000) {
    return new Promise(resolve => {
      const container = document.createElement('div');
      container.id = "progressBarContainer";
      const bar = document.createElement('div');
      bar.id = "progressBar";
      container.appendChild(bar);
      terminalScreen.appendChild(container);

      let startTime = performance.now();

      function update() {
        let elapsed = performance.now() - startTime;
        let percent = Math.min((elapsed / duration)*100, 100);
        bar.style.width = percent + '%';
        if(percent < 100) {
          requestAnimationFrame(update);
        } else {
          setTimeout(() => {
            terminalScreen.removeChild(container);
            resolve();
          }, 700);
        }
      }
      update();
    });
  }

  // Intrusion lines, realistic, pro, with some glitch class to random lines
  const intrusionLines = [
    "[Init] Lancement du protocole de connexion distante...",
    "-> Tentative d'accès SSH vers 192.168.1.12...",
    "-> Authentification par mot de passe : ÉCHEC",
    "-> Tentative de contournement des ACLs en cours...",
    "[Warning] Accès refusé - tentative 1/3",
    "[Warning] Accès refusé - tentative 2/3",
    "[Success] Authentification par clé publique acceptée.",
    "[Info] Extraction des données sensibles en cours...",
    "[Transfer] Exfiltration 0%...",
    "[Transfer] Exfiltration 23%...",
    "[Transfer] Exfiltration 47%...",
    "[Transfer] Exfiltration 68%...",
    "[Transfer] Exfiltration 89%...",
    "[Transfer] Exfiltration 100%.",
    "[Info] Suppression des traces terminée.",
    "[Done] Session terminée avec succès."
  ];

  // Run intrusion terminal simulation
  async function runIntrusion() {
    welcomeScreen.classList.add('hidden');
    cameraScreen.classList.add('hidden');
    redFlash.classList.add('active');

    // Flash rouge 1.5s puis enlever
    await new Promise(r => setTimeout(r, 1500));
    redFlash.classList.remove('active');

    terminalScreen.classList.remove('hidden');
    cameraPreview.classList.remove('hidden');

    // Réduire vidéo caméra en vignette dans le coin
    cameraPreviewVideo.srcObject = stream;

    // Start static noise
    startStaticNoise();

    // Clear terminal text
    terminalScreen.textContent = "";

    // Type each line with bips, errors, glitch, and progress bar
    for(let line of intrusionLines) {
      const error = line.includes("ÉCHEC") || line.includes("Warning") || line.includes("refusé");
      const glitch = Math.random() < 0.3 && !error;

      if(glitch) {
        const glitchSpan = document.createElement('span');
        glitchSpan.className = 'glitch-text';
        glitchSpan.textContent = line;
        terminalScreen.appendChild(glitchSpan);
        terminalScreen.appendChild(document.createTextNode('\n'));
        beep();
        terminalScreen.scrollTop = terminalScreen.scrollHeight;
        await new Promise(r => setTimeout(r, 500 + Math.random() * 400));
      } else if(error) {
        await typeLine("> " + line, 35, true, true);
      } else if(line.includes("[Transfer]")) {
        await typeLine("> " + line, 18, true, false);
        await simulateProgressBar(8000);
      } else {
        await typeLine("> " + line, 22, true, false);
      }
    }

    // Beeps d'erreur finaux puissants
    for(let i=0; i<4; i++) {
      beepError();
      await new Promise(r => setTimeout(r, 320));
    }
    // Stop bruit statique
    stopStaticNoise();

    // Message final clignotant
    const finalAlert = document.createElement('div');
    finalAlert.id = 'finalAlert';
    finalAlert.textContent = ">> TOUTES VOS DONNÉES ONT ÉTÉ TRANSMISES À RIBACK <<";
    terminalScreen.appendChild(finalAlert);

    terminalScreen.scrollTop = terminalScreen.scrollHeight;
  }

  // Start camera event
  btnStartCamera.addEventListener('click', async () => {
    try {
      stream = await navigator.mediaDevices.getUserMedia({video: {facingMode:'user'}});
      cameraVideo.srcObject = stream;
      cameraLoadingText.textContent = "Caméra activée. Préparez-vous...";
      welcomeScreen.classList.add('hidden');
      cameraScreen.classList.remove('hidden');

      if(audioCtx && audioCtx.state === 'suspended') {
        await audioCtx.resume();
      }

      // Intrusion automatique après 7 secondes
      intrusionTimeout = setTimeout(runIntrusion, 7000);

    } catch(e) {
      alert("Erreur d'accès à la caméra : " + e.message);
    }
  });

  // Cleanup on unload
  window.addEventListener('beforeunload', () => {
    if(stream) stream.getTracks().forEach(track => track.stop());
    if(audioCtx) audioCtx.close();
    if(intrusionTimeout) clearTimeout(intrusionTimeout);
  });
</script>

</body>
</html>
